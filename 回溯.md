# 这是回溯的练习

dfs模版
```java
if(){
//记录答案
return；
}

for（//进行可选择的列表选择，如果和顺序无关，用int i=start，如果有关，加入一个boolean的visit）{

}
return;
```
### * leetcode 77
正常的dfs，如果使用组合的话，就用一个begin来加入for循环防止出现1，2 2，1的组合，选反响，如果是和拍的顺序有关的话，要用visit就不用加入begin了,注意剪枝!!!在for中(n-(k-i)+1)
```java
for(int j=m;j<=n-(k-i)+1;j++){
            list.add(j);
            dfs(i+1,n,k,j+1);
            list.remove(list.size()-1);
    }
```

### * leetcode 216(重做) 4.10第一次
关于dfs的start里用的是i+1而不是start+1.

### * leetcode 17
关于异常情况的考虑要到位，记得处理其他按键抛出异常。

### * leetcode 39（重做）4.10第一次
对于可以无限选取自身的组合问题的话，本来dfs中的begin要+1来选去后面位置的数，现在不+1就可以表示能选取自己了。

### * leetcode 40 (重做) 4.10第一次
对于含有重复数字的组合问题，我们在for语句中要加入一个
```java
 if(i>start&&candidates[i]==candidates[i-1]){
                continue;
            }
```
来防止让相同的数字被选两次进行，其中的关键是i>start这样可以选出这是不是第一次。

### * leetcode 131(重做) 4.13第一次
对于字符串的切割成n个字串，选取也可以看作一个组合的问题，比如2 4 之前符合等于一个2 4的组合

### * leetcode 93
对于字符串切割字串，可以想到用dfs递归的方法来做

### 切割字符串总结
其中i不用+1，那种对于n个字串都有要求，或者单个字串有要求的题目可以近似的看为找两个数的组合，从而转化为dfs问题


### * leetcode 78
注意子集问题是求所有树上的点，而不是只到叶子节点的值，这是res.add判断不应该是在末尾

### * leetcode 491（重做）
对于去重和画树要有自己的想法，把数组建立在全局变量等于同时在横向和纵向上去重，如果只是在for循环内等于横向去重.

### 对于回溯树的操作
如果只是对于在横向状态下的同一层的节点操作，就在for前每次都要初始化int[] 或者hashmap，然后在for中进行判断增加，同时不需要恢复现场
但对于纵向状态下的节点操作，就要建立全局变量，在for内进行判断同时要恢复现场！！！

# 这是回溯的练习

dfs模版
```java
if(){
//记录答案
return；
}

for（//进行可选择的列表选择，如果和顺序无关，用int i=start，如果有关，加入一个boolean的visit）{

}
return;
```
### * leetcode 77
正常的dfs，如果使用组合的话，就用一个begin来加入for循环防止出现1，2 2，1的组合，选反响，如果是和拍的顺序有关的话，要用visit就不用加入begin了,注意剪枝!!!在for中(n-(k-i)+1)
```java
for(int j=m;j<=n-(k-i)+1;j++){
            list.add(j);
            dfs(i+1,n,k,j+1);
            list.remove(list.size()-1);
    }
```

### * leetcode 216(重做) 4.10第一次
关于dfs的start里用的是i+1而不是start+1.

### * leetcode 17
关于异常情况的考虑要到位，记得处理其他按键抛出异常。

### * leetcode 39（重做）4.10第一次
对于可以无限选取自身的组合问题的话，本来dfs中的begin要+1来选去后面位置的数，现在不+1就可以表示能选取自己了。

### * leetcode 40 (重做) 4.10第一次
对于含有重复数字的组合问题，我们在for语句中要加入一个
```java
 if(i>start&&candidates[i]==candidates[i-1]){
                continue;
            }
```
来防止让相同的数字被选两次进行，其中的关键是i>start这样可以选出这是不是第一次。

